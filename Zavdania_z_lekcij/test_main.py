import asyncio
from time import sleep, time

fake_users = [
    {'id': 1, 'name': 'April Murphy', 'company': 'Bailey Inc', 'email': 'shawnlittle@example.org'},
    {'id': 2, 'name': 'Emily Alexander', 'company': 'Martinez-Smith', 'email': 'turnerandrew@example.org'},
    {'id': 3, 'name': 'Patrick Jones', 'company': 'Young, Pruitt and Miller', 'email': 'alancoleman@example.net'}
]  #Словник імітація бази даних .


def get_user_sync(uid: int) -> dict: # Функція отримує один аргумент , id користувача, З словника fake_users за ід(ключем) вибирає значення   який потім повертається з функції
                                     # Функція виконана клласично синхроно.
    sleep(0.5) # Пауза в 0,5 сек
    user, = list(filter(lambda user: user["id"] == uid, fake_users)) # Лямда-функція за ключем повертає значеня з словника *fake_users
    return user  # Повернення значення з функції

async def get_user_async(uid: int) -> dict: # Функція отримує один аргумент , id користувача, З словника fake_users за ід(ключем) вибирає значення   який потім повертається з функції
                                     # Функція виконана асинхроно. 
    await asyncio.sleep(0.5)
    user, = list(filter(lambda user: user["id"] == uid, fake_users))
    return user


async def main(): # # Основна функція без аргументів , id користувача, З словника fake_users за ід(ключем) вибирає значення   який в циклі добавляє до списку *r результатів потім повертається з функції
                                     # Функція виконана асинхроно. 
    r = []
    for i in range(1, 4):
        r.append(get_user_async(i))
    return await asyncio.gather(*r) # Повернення з основної асинхроно  функції результату. *await - оператор призупиняє виколнання асинхроної функції до часу завершення виконання асинхроного коду.
                                    # оскільки функція асинхрона то порядок запуску опрацювання даних в ній відбувається порізному не почергово. Оператор дозволяє призупинити виконання функції до процесу поверення результату процесу який запустився перший.
                                    # Черга яка гарантує повернення результатів в тій пслідовності в якій вони потрапили в чергу.
                                    # *asyncio.gather(*r) - метод повертає результат роботи асинхроно функції . Де *r - список аргументів(дані які попаають в обробку асинхроного коду, в нашому випадку це список сформований з словника *fake_users )

    
if __name__ == '__main__': # основна функція коду . В ній реалізовано роботу двох однакових за результатом виконання функціяй одна виконується синхроно(класично), інша асинхроно .
                           # для оцінки роботи цих двох підходів будемо робити замір часу виконання щоб порівняти який з підходів є кращий для них.
    print('------Synchronous Request-----') # Принтемо інофрмацію що це працє синхрона функція.
    start = time() # В зміну *start - передаєм поточний час зауску функції .через функцію *time() модуля *time- повертає поточний час  реального часу.
    for i in range(1, 4): #Цикл в якому буде з словника *fake_users формувати вивід в консоль результату роботи функції *get_user_sync(i) де *i - Поточний ід користувача.
        print(get_user_sync(i)) 
    print(time() - start) # По завершеню циклу визначаємо щераз поточний час функцією *time() віднімає час напочаток запуску роботи функції і принтимо результат (час за який виконась функція) 
    
    print('------Asynchronous Request-----')# Принтемо інофрмацію що це працє асинхрона функція.
    start = time() # Отримуємо поточний час (чапс запуску робти функції)
    result = asyncio.run(main()) # зміній *result повертаємо список виконання асинхроної функції ,asyncio.run(*функція_що_працює_асинхроно)
    for r in result: # Принтемо результат з списку .
        print(r)
    print(time() - start) # Принтемо різницю в час між запуском роботи функції і поточним часом(завершення роботи функції.)

    # Висновок . що асинхроний метод Працює прблизно в 3-2,5 рази швидше для робти з базами даних Принаймі в такій реалізації яку ми виконали.
    # асинхроний методи швидший у всіх випадках де потрібно вводити і вводити результат Саме ці процеси і займають найбільше часу в виконанні програм.
    # оскільки в снхроному методі все відбувається класично. надходить заит , його обробляє функція далі повертає резулат , і в момент коли результат виводиться потік роботи функції нічого неробить поки йому не надійде новий запит
    # В асинхроному методі функція виконує роботи  всіма результами навіть нечекаючи на вивід . За допомогою оператора *await - результати виконання асинхроної функції призупиняються і коли всі результати вже будуть вирахування почнеться вивід їх в такомуж порядку як вони почали надходити в функцію.
    # відповідно скорочується час на переключення потоків з обрахунку на вивід . Спочатку виконуються всі обрахунки а потів виконуєься весь виввід всі результатів,
    # це прискорює роботу як ми бачимо в 2 - 3 раздля такого типу функції. 