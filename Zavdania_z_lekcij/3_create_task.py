# ================================ Модуль asyncio(асинхроне програмування) - Використаня модуля *faker(псевдо База Даних) ================
# +++++++++++++++++++++++++++ Основне задання реалізувати отримання проміжних резульатів через створення *task а не через список ++++++++++++++++++
# *task - екзепляр  містить не тільки конкертний результат ай багато інших важливих даних (помилки які могли виникнути при створенні екзепляра, час його створення та інше)



import asyncio

from time import sleep, time

from faker import Faker

fake = Faker("uk-UA") # З бібліотеки *faker(одаткова бібліотека потібно інсталювати , має набиту базу з різними випадковими даними ,іменами , скриньками та іншими параметрами для тестової роботи з базами даних )
                      # Створюєм екзепляр класу  *Faker ("*код_країни_")Примітка взалежності від мемо коду країни буде видавати дані з відповідними для цієї країни іменами і парамтерами їх громадян.

def get_user_from_db (uuid : int) : # Функція приймає 1 аргумент , ід користувача і заним повертає відповідний запис з ід що обрали , імям, і емайлом з БД
                                    # Реалізовано класично . Синхроний код
    sleep(0.5)

    return {"id": uuid , "username": fake.user_name(), "email": fake.email() }

async def async_get_user_from_db (uuid : int) :  # Функція(та сама щой для синхроного) приймає 1 аргумент , ід користувача і заним повертає відповідний запис з ід що обрали , імям, і емайлом з БД
                                    # Реалізовано асинхроно. 
    
    await asyncio.sleep(0.5) # Для реалізації асинхроної функції використовуємо оператор *await і модуль asyncio.*функція_яку_будемо_виконувати_асинхоно

    return {"id": uuid , "username": fake.user_name(), "email": fake.email() }

async def main(): # Реалізація основниї функції *main() асинхоним метод.
    users= [] # CСписок в який будемо дбавляти наших користувачів з БД *Faker("uk-UA")
    for i in range(1,5): # Цикл в якому генеруємо 4 випадковх рядків з БД *Faker("uk-UA") з id від 1 до 5 (невключно)
        
        task = asyncio.create_task(async_get_user_from_db (i)) # Створення *task(аналг проміс для Java Script) - отримання проміжних результатів але вже з можливими помилками та іншою корисною інформацією для подальшого опрацювання.
        users.append(task)
    print(users) # Пірнтемо базову інформацію полів task
    result = await asyncio.gather(*users)
    return result



if __name__ == "__main__" :

    start = time() # В зміну *start передаєм значення поточного часу , Потрібно щоб зробити замір часу виконання нашої функції.
    for i in range(1,5): # Цикл в якому генеруємо 4 випадковх рядків з БД *Faker("uk-UA") з ід від 1 до 5 (невключно)
        user = get_user_from_db(i) # в зміну *user передаєм результат роботи нашої функції *get_user_from_db(i)
        print(user)

    print(time() - start) # Прінтимо різницю Поточного часу і часу на момент запуску функції. Отримуємо час виконання функці.

    #print(get_user_from_db(1)) # Принтемо резуьтат роботи функції *get_user_from_db(1) де 1 id Бази даних (внашому випадку БД *Faker("uk-UA") )

    start = time() # В зміну *start передаєм значення поточного часу , Потрібно щоб зробити замір часу виконання нашої функції.
     # Цикл в якому генеруємо 4 випадковх рядків з БД *Faker("uk-UA") з ід від 1 до 5 (невключно)
    users = asyncio.run(main()) # в зміну *users передаєм результат роботи нашої асинхроної функції  *async def main(), функція *asyncio.run(*асинхрона_функція)- запускає асинхроні процеси переданої функції.
    print(users) # Принтемо результ асинхроної функції . Отримаємо список словників з ДБ *Faker("uk-UA") , за вказаним id заданими в *async_get_user_from_db (uuid : int)

    print(time() - start) # Прінтимо різницю Поточного часу і часу на момент запуску функції. Отримуємо час виконання функції.
    # Примітка : замсть короткого запису *users = asyncio.run(main()) в старих кодах можна зустріти наступне 
                                        
                                        # loop = asyncio.new_event_loop() 
                                        # asyncio.set_event_loop(loop)
                                        # users= loop.run_until_complete(main()) # це все внових версіях пайтом 3.10 і вище замінено однією стрічкою *users = asyncio.run(main())