#  ========================================= Модуль asyncio(асинхроне програмування)  клас *Future ================================================

# ================================ Модуль asyncio(асинхроне програмування) - Використаня модуля *faker(псевдо База Даних) ================
# +++++++++++++++++++++++++++ Основне задання реалізувати отримання проміжних резульатів через створення *task а не через список ++++++++++++++++++
# *task - екзепляр  містить не тільки конкертний результат ай багато інших важливих даних (помилки які могли виникнути при створенні екзепляра, час його створення та інше)
# добдатково реалізовано *wraper і декоратор *@async_timed("Початок роботи") Реалізацію дивись в файлі *timing.py


import asyncio

from time import sleep, time

from faker import Faker
from timing import async_timed # імпортуємо нами написану функцію *async_timed(name)-для заміру часу виконнання асинхроних функції , 
                                # з нами написаного модуля *timing (файл *timing.py має бути в ційже папці де код в якому схочемо використати власноруч написаний модуль)

fake = Faker("uk-UA") # З бібліотеки *faker(одаткова бібліотека потібно інсталювати , має набиту базу з різними випадковими даними ,іменами , скриньками та іншими параметрами для тестової роботи з базами даних )
                      # Створюєм екзепляр класу  *Faker ("*код_країни_")Примітка взалежності від мемо коду країни буде видавати дані з відповідними для цієї країни іменами і парамтерами їх громадян.

# def get_user_from_db (uuid : int) : # Функція приймає 1 аргумент , ід користувача і заним повертає відповідний запис з ід що обрали , імям, і емайлом з БД
#                                     # Реалізовано класично . Синхроний код
#     sleep(0.5)

#     return {"id": uuid , "username": fake.user_name(), "email": fake.email() }

async def async_get_user_from_db (uuid : int, future:asyncio.Future ) :  # Функція(та сама щой для синхроного) приймає 2 аргументb , ід користувача і *future -екзепляр типу *asyncio.Future -
    #  заним повертає відповідний запис з ід що обрали , імям, і емайлом з БД
                                    # Реалізовано асинхроно. 
    
    await asyncio.sleep(0.5) # Для реалізації асинхроної функції використовуємо оператор *await і модуль asyncio.*функція_яку_будемо_виконувати_асинхоно

    future.set_result({"id": uuid , "username": fake.user_name(), "email": fake.email() }) # На основі *uuid з нашої БД створює екзепляр класу *Future() 
                                    # за допомогою функції *імя_екзепляра.set_result(*якийсь_словник(запис_з_БД))

def make_request (uuid)-> asyncio.Future: # Функція приймає 1 аргумент *uuid , повертає на основі його основі екзепляр класу *Future
    future = asyncio.Future() # Створюємо пустий екзепляр класу *asyncio.Future()
    asyncio.create_task(async_get_user_from_db(uuid, future)) # Створюємо *task на основі конкретного екзепляра *Future() повернутого з функції *async_get_user_from_db(uuid, future)
    return future # повертаємо з функції створений екзепляр *future




@async_timed("Початок роботи") # Встановлення власного декоратора який будем робити замір час викоання функції в нашому випадку *async def main()
 # Реалізація основниї функції *main() асинхоним метод.
async def main():
    users= [] # CСписок в який будемо дбавляти наших користувачів з БД *Faker("uk-UA")
    for i in range(1,5): # Цикл в якому генеруємо 4 випадковх рядків з БД *Faker("uk-UA") з id від 1 до 5 (невключно)
        
       users.append(make_request(i))
    print([user.done() for user in users]) # Прінтемо базову інформацію полів *future, *user.done() -де *user- екзепляр класу *Future, 
                                            # *імя_екзепляру_Future.done() - вбудований метод класу *Future який повертає False якщо робота future ще невиконана і
                                            #  І True якощо опрацювання вже завершилось і є результат
    result = await asyncio.gather(*users)   # Формуємо результат роботи функції методом *asyncio.gather(*args) - отримує як аргументи екзепляри класу Future чи інші повертає початковий їх вигляд (словники, списки,кортежі та інші)
                                            # Примітка : Так званий Зборщик. Отримує екзеплри класів повертає типові значення з яких вони утворені.
    print([user.done() for user in users])  # Прінтемо базову інформацію полів *future, *user.done() -де *user- екзепляр класу *Future,
                                            # Приімтка : Прінтимо ще раз щоб перевірити чи всі запити завершились успішно . якщо так то поверне стільки раз True скільки запитів було оброблено успіщно
    return result                           # Повертаємо результат роботи асинхроної функції . В нашому випадку буде список словників з нашої БД *fake



if __name__ == "__main__" :

   
        # start = time() # В зміну *start передаєм значення поточного часу , Потрібно щоб зробити замір часу виконання нашої функції.
        # наразі рядок вище закоментований оскільки ми підключили власний модуль для обрахунку часу викоання функції через декортор і функцію *wraper
        #  Примітка: дивись файл *timing.py 
     
    users = asyncio.run(main()) # в зміну *users передаєм результат роботи нашої асинхроної функції  *async def main(), функція *asyncio.run(*асинхрона_функція)- запускає асинхроні процеси переданої функції.
    print(users) # Принтемо результ асинхроної функції . Отримаємо список словників з ДБ *Faker("uk-UA") , за вказаним id заданими в *async_get_user_from_db (uuid : int)

        #print(time() - start) # Прінтимо різницю Поточного часу і часу на момент запуску функції. Отримуємо час виконання функції.
    # Примітка : замсть короткого запису *users = asyncio.run(main()) в старих кодах можна зустріти наступне 
                                        
                                        # loop = asyncio.new_event_loop() 
                                        # asyncio.set_event_loop(loop)
                                        # users= loop.run_until_complete(main()) # це все внових версіях пайтом 3.10 і вище замінено однією стрічкою *users = asyncio.run(main())